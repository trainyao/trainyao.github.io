<!DOCTYPE html>
<html lang="zh-cn">

	<head>
		<title> all &middot; trainyao.github.io </title>

		<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.59.1" />


<script   src="https://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">


<link rel="stylesheet" href="https://trainyao.github.io/css/nix.css">


<link href="https://fonts.googleapis.com/css?family=Inconsolata%7COpen+Sans%7CConcert+One" rel="stylesheet">




	</head>

	<body>
		<header>
<nav class="navbar navbar-default navbar-fixed-top navbar-inverse font-header">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" id="green-terminal" href=https://trainyao.github.io/>trainyao@home ~ $</a>
		</div>

		
		<div class="collapse navbar-collapse" id="navbar-collapse-1">
			<ul class="nav navbar-nav navbar-right">
				<li>
					<a href="https://trainyao.github.io/">/home/trainyao</a>
				</li>
				
				
				<li class="dropdown">
                    
            		<a href="/post/">~/all</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">category <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        
                    		<li>
                    		<a href="/categories/kubernetes/">~/kubernetes</a>
				    		</li>
                		
                    		<li>
                    		<a href="/categories/istio/">~/service mesh/istio</a>
				    		</li>
                		
                    		<li>
                    		<a href="/categories/gloo/">~/service mesh/envoy/gloo</a>
				    		</li>
                		
                    		<li>
                    		<a href="/categories/mosn/">~/service mesh/mosn</a>
				    		</li>
                		
                    		<li>
                    		<a href="/categories/skynet/">~/skynet</a>
				    		</li>
                		
                    		<li>
                    		<a href="/categories/%E8%84%91%E6%B4%9E/">~/脑洞</a>
				    		</li>
                		
                    		<li>
                    		<a href="/categories/%E5%85%B6%E4%BB%96/">~/其他</a>
				    		</li>
                		
                    		<li>
                    		<a href="/categories/%E7%BF%BB%E8%AF%91/">~/翻译</a>
				    		</li>
                		
                    		<li>
                    		<a href="/categories/kubernetes-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">~/读书笔记/kubernetes 权威指南</a>
				    		</li>
                		
                    		<li>
                    		<a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">~/读书笔记/深入理解计算机系统</a>
				    		</li>
                		
            		</ul>
            		
        		</li>
        		

			</ul>
		</div>
	</div>
</nav>
</header>

		<div class="container wrapper">
			<div class="row">
				<div class="col-xs-12 text-center">
					<h1 id=>all</h1>
				</div>
			</div>
			<ul id="post-list">
                	
				<li>
					<div class="post-list-item">
						<div class="post-header">
							<h4 class="post-link"><a href="https://trainyao.github.io/post/mosn/source_shm/">MOSN 源码分析 - 共享内存模型</a></h4>
							<h4 class="post-date">Feb 23, 2020</h4>
						</div>
						<div class="post-summary"><p>本文记录了对 MOSN 的源码研究 - MOSN 的共享内存模型。
本文的内容基于 MOSN v0.9.0，commit id b2a239f5。
机制 MOSN 用共享内存来存储 metrics 信息。MOSN 用 mmap 将文件映射到内存，在内存数组之上封装了一层关于 metrics 的存取逻辑，实现了 go-metrics 包的关于 metrics 的接口，通过这种方式组装出了一种基于共享内存的 metrics 实现供 MOSN 使用。
创建共享内存：Mmap 操作共享内存的方法主要在 pkg/shm/shm.go 文件下：
func Alloc(name string, size int) (*ShmSpan, error) { ... return NewShmSpan(name, data), nil } func Free(span *ShmSpan) error { Clear(span.name) return syscall.Munmap(span.origin) } func Clear(name string) error { return os.Remove(path(name)) }  都是围绕着 ShmSpan 结构体的几个操作方法。再来看 ShmSpan 结构体：</p></div>
						<div class="post-list-footer text-center">
							<a href="https://trainyao.github.io/post/mosn/source_shm/">Read More</a>
						</div>
					</div>
				</li>
			
				<li>
					<div class="post-list-item">
						<div class="post-header">
							<h4 class="post-link"><a href="https://trainyao.github.io/post/mosn/source_buffer/">MOSN 源码分析 - 内存复用机制</a></h4>
							<h4 class="post-date">Feb 15, 2020</h4>
						</div>
						<div class="post-summary"><p>本文记录了对 MOSN 的源码研究 - MOSN 的内存复用机制。
本文的内容基于 MOSN v0.9.0，commit id 1609ae14。
MOSN 在内存管理复用方面有 内存对象注册/管理 和 byte/io buffer 复用 两部分内容。MOSN 最新的 master 分支用了 mod 管理依赖， 发现后一部分也迁移到了 vendor 目录下，可单独使用。下面就分这两部分来讲述 MOSN 的内存复用机制。
机制 简述一下两部分内容的机制，具体实现原理会在后面带上源码解析。
1. 内存对象注册/管理 MOSN 在 go sync 包外，对 sync.Pool 对象进行了进一步封装，增加了管理和易用性。
MOSN 的 buffer 包提供了注册函数和统一的接口。将实现了接口的不同类型的 buffer 对象注册到 buffer 包， 在用到的使用通过 buffer 包导出的方法进行初始化和管理，增强了内存对象的管理。
而易用性方面，MOSN 封装了 bufferValue 对象，管理上面初始化出来的对象，并且将 bufferValue 对象也进行了池化管理。在这之上，封装出方法 NewBufferPoolContext 和 PoolContext，使内部根据 context 传值的场景更加易用。MOSN 里面在不同协程协作（比如连接被协程1 accept 后， 交由 worker 协程2 进行 IO）的过程，会将必要参数使用内部实现的 context with value 机制进行传递， 其中 buffer 传递的方法就是通过上述封装的方法进行传递的。</p></div>
						<div class="post-list-footer text-center">
							<a href="https://trainyao.github.io/post/mosn/source_buffer/">Read More</a>
						</div>
					</div>
				</li>
			
				<li>
					<div class="post-list-item">
						<div class="post-header">
							<h4 class="post-link"><a href="https://trainyao.github.io/post/mosn/source_filter/">MOSN 源码分析 - 插件机制</a></h4>
							<h4 class="post-date">Feb 9, 2020</h4>
						</div>
						<div class="post-summary"><p>本文记录了对 MOSN 的源码研究 - MOSN 的插件机制, 以及如何创建自己的插件来扩展 MOSN。
本文的内容基于 MOSN v0.9.0。
机制 使用过滤器模式来实现扩展是常见的设计模式，MOSN 也是使用了这种方式来构建可扩展性。
MOSN 把过滤器相关的代码放在了 pkg/filter 目录下：
➜ mosn git:(2c6f58c5) ✗ ll pkg/filter total 24 drwxr-xr-x 8 mac staff 256 Feb 5 08:52 . drwxr-xr-x 30 mac staff 960 Feb 5 08:52 .. drwxr-xr-x 3 mac staff 96 Aug 28 22:37 accept -rw-r--r-- 1 mac staff 2556 Feb 5 08:52 factory.go -rw-r--r-- 1 mac staff 2813 Feb 5 08:52 factory_test.</p></div>
						<div class="post-list-footer text-center">
							<a href="https://trainyao.github.io/post/mosn/source_filter/">Read More</a>
						</div>
					</div>
				</li>
			
				<li>
					<div class="post-list-item">
						<div class="post-header">
							<h4 class="post-link"><a href="https://trainyao.github.io/post/gloo/gloo_in_non_kubernetes_env_gateway_02/">使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 路由能力: tcp / http</a></h4>
							<h4 class="post-date">Jan 31, 2020</h4>
						</div>
						<div class="post-summary"><p>本系列文章主要介绍了在非 kubernetes 环境，使用 gloo 搭建服务网关的过程，以及 gloo 的简单的使用指南。
系列文章目录如下:
 使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 初识 gloo 使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 路由能力: tcp / http [使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 路由能力: grpc][3] [使用 gloo 在非 kubernetes 环境搭建服务网关指南 - envoy 高可用、错误注入、超时控制、熔断][4] [使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 指标监控、报警][5] [使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 链路跟踪][6] [使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 权限、流控][7]  上篇文章主要简单介绍了 gloo 以及在非 k8s 环境下运行了简单的 gloo demo。 接下来两篇文章我会简单讲述一下 gloo 的路由能力。</p></div>
						<div class="post-list-footer text-center">
							<a href="https://trainyao.github.io/post/gloo/gloo_in_non_kubernetes_env_gateway_02/">Read More</a>
						</div>
					</div>
				</li>
			
				<li>
					<div class="post-list-item">
						<div class="post-header">
							<h4 class="post-link"><a href="https://trainyao.github.io/post/gloo/gloo_in_non_kubernetes_env_gateway_01/">使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 初识 gloo</a></h4>
							<h4 class="post-date">Jan 30, 2020</h4>
						</div>
						<div class="post-summary"><p>本系列文章主要介绍了在非 kubernetes 环境，使用 gloo 搭建服务网关的过程，以及 gloo 的简单的使用指南。
系列文章目录如下:
 使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 初识 gloo 使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 路由能力: tcp / http [使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 路由能力: grpc][3] [使用 gloo 在非 kubernetes 环境搭建服务网关指南 - envoy 高可用、错误注入、超时控制、熔断][4] [使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 指标监控、报警][5] [使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 链路跟踪][6] [使用 gloo 在非 kubernetes 环境搭建服务网关指南 - 权限、流控][7]  首先: 使用非 kubernetes 环境意义何在?  调试快速</p></div>
						<div class="post-list-footer text-center">
							<a href="https://trainyao.github.io/post/gloo/gloo_in_non_kubernetes_env_gateway_01/">Read More</a>
						</div>
					</div>
				</li>
			
				<li>
					<div class="post-list-item">
						<div class="post-header">
							<h4 class="post-link"><a href="https://trainyao.github.io/post/mosn/reconfig/">mosn 的reconfig 机制</a></h4>
							<h4 class="post-date">Nov 24, 2019</h4>
						</div>
						<div class="post-summary"><p>本文记录了对 mosn 的源码研究，研究 mosn 是如何做到平滑重启的。
本文的内容基于 mosn v0.8.1。
我们先将被重启的 mosn 进程称为 旧 mosn，将重启并接管流量的进程成为 新 mosn。
1. 机制 mosn 没有使用重新读取 config 文件的方法来实现 reconfig，而是通过 unix socket 作为进程间通信，并将旧进程的监听 fd 通过 socket 传过去，新 mosn 接管 fd 并且重新读取 config，旧 mosn 进行 gracefully shutdown，以达到 reconfig 和平滑重启的功能。
2. 旧mosn 我们先从一个启动着的 mosn 进程看起，看看它是如何被重启的。
mosn 的 reconfig 逻辑在 server 包的 reconfigure.go 内。
mosn 进程启动后，会创建一个叫 reconfig.sock 的 unix socket，创建一个协程，开始监听并往里面写入一个字节的内容，这时会出现写阻塞。一旦有另一个进程从 reconfig.sock 读取到这一个字节，旧 mosn 便开始 reconfig 逻辑。
reconfig 逻辑:  当写阻塞结束，协程会尝试链接另一个 unix socket ：listen.</p></div>
						<div class="post-list-footer text-center">
							<a href="https://trainyao.github.io/post/mosn/reconfig/">Read More</a>
						</div>
					</div>
				</li>
			
				<li>
					<div class="post-list-item">
						<div class="post-header">
							<h4 class="post-link"><a href="https://trainyao.github.io/post/kubernetes/ca_for_admission_controller/">使用 kubernetes 的 CA 证书自签名服务端 &amp; 客户端证书</a></h4>
							<h4 class="post-date">Jan 12, 2019</h4>
						</div>
						<div class="post-summary"><p>安装 cfssl
wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 chmod +x cfssl_linux-amd64 mv cfssl_linux-amd64 /usr/local/bin/cfssl wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 chmod +x cfssljson_linux-amd64 mv cfssljson_linux-amd64 /usr/local/bin/cfssljson wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 chmod +x cfssl-certinfo_linux-amd64 mv cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certinfo export PATH=/usr/local/bin:$PATH  找到 kubernetes 的根证书 ca.pem, ca-key.pem, ca-config.json
 生成证书请求配置文件, 可以替换 usage 为其他名字, 替换 usage.common.name 为服务器域名
cat &gt; usage.json &lt;&lt;EOF { &quot;CN&quot;: &quot;usage.common.name&quot;, &quot;key&quot;: { &quot;algo&quot;: &quot;rsa&quot;, &quot;size&quot;: 2048 }, &quot;names&quot;: [ { &quot;C&quot;: &quot;CN&quot;, &quot;ST&quot;: &quot;BeiJing&quot;, &quot;L&quot;: &quot;BeiJing&quot;, &quot;O&quot;: &quot;k8s&quot;, &quot;OU&quot;: &quot;System&quot; } ], &quot;ca&quot;: { &quot;expiry&quot;: &quot;87600h&quot; } } EOF  用 cfssl 工具签名服务端证书</p></div>
						<div class="post-list-footer text-center">
							<a href="https://trainyao.github.io/post/kubernetes/ca_for_admission_controller/">Read More</a>
						</div>
					</div>
				</li>
			
				<li>
					<div class="post-list-item">
						<div class="post-header">
							<h4 class="post-link"><a href="https://trainyao.github.io/post/istio/traffic_hijeack_practise/">istio 流量劫持实验</a></h4>
							<h4 class="post-date">Dec 8, 2018</h4>
						</div>
						<div class="post-summary"><p>istio 是通过给每个生产 pod 注入一个 envoy sidecar 进行流量劫持的。注入后，流入 pod 的流量和 pod 请求的流量都会经过 sidecar 进行路由。
这样的流量劫持是通过 sidecar pod 和生产 pod 共享一个网络命名空间，然后设置 iptable 规则实现的。
PS1：下面的步骤前提是在一个 k8s 集群内操作，并且已经安装了 istio） PS2：实验步骤是基于宋大的博文上实验的，可以先看看宋大的两篇博文：用 vagrant 和 virtualbox 搭建一个 k8s 集群 理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持
1.sidecar 是如何注入的呢？ 比如我们要部署一个服务，首先要编写一个关于 service 和 deployment 的 yaml 文件（拿 istio 官网的 bookinfo 为例子）：
--- apiVersion: v1 kind: Service metadata: name: productpage labels: app: productpage spec: ports: - port: 9080 name: http selector: app: productpage --- apiVersion: extensions/v1beta1 kind: Deployment metadata: name: productpage-v1 spec: replicas: 1 template: metadata: labels: app: productpage version: v1 spec: containers: - name: productpage image: istio/examples-bookinfo-productpage-v1:1.</p></div>
						<div class="post-list-footer text-center">
							<a href="https://trainyao.github.io/post/istio/traffic_hijeack_practise/">Read More</a>
						</div>
					</div>
				</li>
			
				<li>
					<div class="post-list-item">
						<div class="post-header">
							<h4 class="post-link"><a href="https://trainyao.github.io/post/translate/kubernetes_and_ipvs/">Kubernetes 使用 IPVS/LVS 作为网络服务代理</a></h4>
							<h4 class="post-date">Sep 18, 2018</h4>
						</div>
						<div class="post-summary"><p>本文翻译自：https://cloudnativelabs.github.io/post/2017-05-10-kube-network-service-proxy/
服务是 Kubernetes 的一个抽象概念。服务将一组逻辑上的、提供相同功能的 pod 组合在一起。一个在 Kubernetes 内的服务可以是多种类型的，比如 ‘ClusterIP’ 和 ‘NodePort’ 类型实现服务发现和负载均衡。这些服务的类型的实现都需要一个运行在各个 Kubernetes 集群节点的服务代理。Kubernetes 有一种名为 ‘kube-proxy’ 的代理，是基于 iptable 实现的。虽然，kube-proxy 提供了一种开箱即用的代理解决方案，它并不是一种最优的方案。在这篇文章里，我们会深入研究另一种 Kubernetes 里网络服务代理的实现：kube-router，它是基于 Liunx IPVS 的。我们还会讨论基于 iptables 的 kube-proxy 的好处与不足，以及将它与基于 IPVS/LVS 实现的 Kubernetes 网络服务代理进行对比。
请看下面的 demo，感受 IPVS 实现的 kube-router 作为 Kubernetes 服务代理的效果。
（此处查看原文可以看到 asciinema demo，如果不能访问，asciinema 地址在这里）
下面我们来深入研究一下细节。
ClusterIP 和 NodeProt 类型的服务 在服务的生命周期里，每个 ‘ClusterIP’ 和 ‘NodePort’ 服务会被分配一个唯一的 IP 地址（称为 ClusterIP）。Kubernetes 会配置 Pods 通过 ClusterIP 与服务进行交互，而且 pods 发送至 service 的请求会被自动地负载均衡到 service 的成员 pods 上。另外，Kubernetes master 节点会为 ‘NodePort’ 类 service 分配一个标志配置范围（默认是 30000 至 23767）的端口，然后每个 node 节点会将该 service 的请求代理到这个端口上。</p></div>
						<div class="post-list-footer text-center">
							<a href="https://trainyao.github.io/post/translate/kubernetes_and_ipvs/">Read More</a>
						</div>
					</div>
				</li>
			
				<li>
					<div class="post-list-item">
						<div class="post-header">
							<h4 class="post-link"><a href="https://trainyao.github.io/post/bookread/kubernetes_the_definitive_guide/kubernetes_architecture/">kubernetes是怎么工作的以及其架构</a></h4>
							<h4 class="post-date">Sep 16, 2018</h4>
						</div>
						<div class="post-summary"><p>本文简单概括了 kubernetes 里有什么组件，以及它们是如何工作的。
一、kubernetes 的组件和架构 一个 kubernetes 集群包含两部分：master 节点和 node 节点。master 节点负责接收管理员对于 kubernetes 资源对象的修改，并根据这些修改，对 node 节点进行配置和调度。node 节点是 kubernetes 集群内的计算节点，负责给部署在上面的业务应用提供计算以及储存能力。
kubernetes 里有以下组件：Kubernetes API Server、Controll Manager、Scheduler、kubelet 和 kube-proxy。
其中，Kubernetes API Server、Controll Manager、Scheduler 运行在 master节点上。而 kubelet 和 kube-proxy 运行在 node 节点上。
这些组件分别负责 kubernetes 运行的不同职责：
 Kubernetes API Server：kubernetes 集群的管理入口，它提供 HTTP REST 接口给 kubernetes 用户进行集群的配置，这些配置将会保存在 master 节点运行的 etcd 里面，供其他组件查阅。
 Controll Manager：负责监听 etcd 变化并作出对应的动作。Controll Manager 是一系列 manager 的统称，其中有以下这些manager：
 Replication Manager：负责 node 节点的 pod 管理。 Node Controller：负责 node 节点管理。 Namespace Controller：负责管理集群内的命名空间。 ResourceQuota Controller：负责针对 namespace、pod、容器这三个维度的资源限制管理。 ServiceAccount Controller：负责管理集群内访问的账号。 Token Controller：负责允许访问 kubernetes 集群的 token。 Service Controller：负责管理集群内的 Service。 Endpoint Controller：负责管理集群内的 Endpoint。  Scheduler：负责接收 Replication Controller 的指挥，对要部署在 node 上的 pod 进行调度。Scheduler 会根据调度算法以及调度策略，调度 pod 在哪个 node 上部署。</p></div>
						<div class="post-list-footer text-center">
							<a href="https://trainyao.github.io/post/bookread/kubernetes_the_definitive_guide/kubernetes_architecture/">Read More</a>
						</div>
					</div>
				</li>
			
			</ul>
            

<div class="pagination-wrapper text-center">
  <ul class="pagination">
      
      <li>
          <a href="/post/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      
      <li
      class="disabled">
          <a href="" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
      </li>
      
      <li
      class="active"><a href="/post/">1</a></li>
      
      <li
      ><a href="/post/page/2/">2</a></li>
      
      <li
      >
          <a href="/post/page/2/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
      </li>
      
      <li>
          <a href="/post/page/2/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
      
    </ul>
</div>



			<div class="push"></div>
		</div>
		<footer class="footer text-center">
<p>Copyright &copy; 2020 Hello, I&#39;m trainyao. -
<span class="credit">
	Powered by
	<a target="_blank" href="https://gohugo.io">Hugo</a>
	and
	<a target="_blank" href="https://github.com/LordMathis/hugo-theme-nix/">Nix</a> theme.
</span>
</p>
</footer>

	</body>
</html>
