<!DOCTYPE html>
<html>

    <head>
        <title> MOSN 源码分析 - 内存复用机制 &middot; trainyao.github.io </title>

        <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.59.1" />


<script   src="https://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">


<link rel="stylesheet" href="https://trainyao.github.io/css/nix.css">


<link href="https://fonts.googleapis.com/css?family=Inconsolata%7COpen+Sans%7CConcert+One" rel="stylesheet">




    </head>

    <body>
        <header>
<nav class="navbar navbar-default navbar-fixed-top navbar-inverse font-header">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" id="green-terminal" href=https://trainyao.github.io/>trainyao@home ~ $</a>
		</div>

		
		<div class="collapse navbar-collapse" id="navbar-collapse-1">
			<ul class="nav navbar-nav navbar-right">
				<li>
					<a href="https://trainyao.github.io/">/home/trainyao</a>
				</li>
				
				
				<li class="dropdown">
                    
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">日志 <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        
                    		<li>
                    		<a href="/post/kubernetes">~/kubernetes</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/istio">~/service mesh/istio</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/gloo">~/service mesh/envoy/gloo</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/mosn">~/service mesh/mosn</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/skynet">~/skynet</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/translate">~/翻译</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/bookread/kubernetes_the_definitive_guide">~/读书笔记/kubernetes 权威指南</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/bookread/computer_system">~/读书笔记/深入理解计算机系统</a>
				    		</li>
                		
            		</ul>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
            		<a href="/post/thoughts">~/脑洞</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">其他 <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        
                    		<li>
                    		<a href="/post/other/repid_develop">~/快速开发</a>
				    		</li>
                		
            		</ul>
            		
        		</li>
        		

			</ul>
		</div>
	</div>
</nav>
</header>

        <div class="container wrapper">
            <h1><a href="https://trainyao.github.io/post/mosn/source_buffer/">MOSN 源码分析 - 内存复用机制</a></h1>
            <span class="post-date">Feb 15, 2020 </span>
            <div class="post-content">
                

<p>本文记录了对 MOSN 的源码研究 - MOSN 的内存复用机制。</p>

<p>本文的内容基于 MOSN v0.9.0，commit id 1609ae14。</p>

<p>MOSN 在内存管理复用方面有 <code>内存对象注册/管理</code> 和 <code>byte/io buffer 复用</code> 两部分内容。MOSN 最新的 master 分支用了 mod 管理依赖，
发现后一部分也迁移到了 vendor 目录下，可单独使用。下面就分这两部分来讲述 MOSN 的内存复用机制。</p>

<h2 id="机制">机制</h2>

<p>简述一下两部分内容的机制，具体实现原理会在后面带上源码解析。</p>

<h3 id="1-内存对象注册-管理">1. 内存对象注册/管理</h3>

<p>MOSN 在 go <code>sync</code> 包外，对 <code>sync.Pool</code> 对象进行了进一步封装，增加了管理和易用性。</p>

<p>MOSN 的 buffer 包提供了注册函数和统一的接口。将实现了接口的不同类型的 buffer 对象注册到 buffer 包，
在用到的使用通过 buffer 包导出的方法进行初始化和管理，增强了内存对象的管理。</p>

<p>而易用性方面，MOSN 封装了 <code>bufferValue</code> 对象，管理上面初始化出来的对象，并且将 bufferValue 对象也进行了池化管理。在这之上，封装出方法
<code>NewBufferPoolContext</code> 和 <code>PoolContext</code>，使内部根据 context 传值的场景更加易用。MOSN 里面在不同协程协作（比如连接被协程1 accept 后，
交由 worker 协程2 进行 IO）的过程，会将必要参数使用内部实现的 <code>context with value</code> 机制进行传递，
其中 buffer 传递的方法就是通过上述封装的方法进行传递的。</p>

<h3 id="2-byte-io-buffer-复用">2. byte/io buffer 复用</h3>

<p>为了提高 byte 数组的复用率，MOSN 封装出了对齐64字节的 byte buffer pool 管理，以及在其之上的 io buffer pool 管理包，内部需要用到的时候可以直接调用。</p>

<p>之前这部分代码是放在 pkg 下的，在最新的 master 迁移到了 vendor 下，不依赖 pkg 包下任何的其他包。这种情况下如果开发者自己
的项目有这部分需求，其实也可以直接使用 MOSN 写好的包，不用重复造轮子。</p>

<h2 id="源码解析">源码解析</h2>

<h3 id="1-内存对象注册-管理-1">1. 内存对象注册/管理</h3>

<h4 id="注册管理">注册管理：</h4>

<p>这是 bufferPool 相关的简单类图。</p>

<p><img src="./class.png" alt="" /></p>

<p>MOSN 定义了 <code>bufferPoolCtx</code> 接口，使用 buffer 包需要将实现了这个接口的对象，比如图中的 ABufferCtx、BBufferCtx，通过 <code>RegisterBuffer</code> 方法注册到 buffer 包。</p>

<p>其中 <code>Index()</code> 方法返回注册时写入的 index 值；<code>New()</code> 方法是用来初始化待缓存对象的；而 <code>Reest()</code> 方法是将内存对象放回 pool 前的重置逻辑。</p>

<p><a href="https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L70">https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L70</a></p>

<pre><code class="language-go">RegisterBuffer(poolCtx types.BufferPoolCtx) {
	...
	bPool[i].ctx = poolCtx
	setIndex(poolCtx, int(i))
	...
</code></pre>

<p>注册过程大致是将传入的对象保存在全局变量 bPool 中，并给它分配一个全局唯一的 index 值作为标记。</p>

<p>注册后的结构图大概是这样的：</p>

<p><img src="./struct.png" alt="" /></p>

<p>bPool 全局变量保存着已注册的 index 值 到 bufferPool 对象的索引, 在需要获取对象时根据 index 值找到对应的 pool，调用 ctx.New()，或 sync.Pool.Get()；
在需要 give 对象时，先调用 ctx.Reset() 方法对复用对象进行重置，然后调用 sync.Pool.Put()，至此实现了对 sync.Pool 的封装管理和扩展。</p>

<p><a href="https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L91">https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L91</a></p>

<pre><code class="language-go">// Take returns a buffer from buffer pool
func (p *bufferPool) take() (value interface{}) {
	value = p.Get()
	if value == nil {
		value = p.ctx.New()
	}
	return
}

// Give returns a buffer to buffer pool
func (p *bufferPool) give(value interface{}) {
	p.ctx.Reset(value)
	p.Put(value)
}
</code></pre>

<h4 id="易用性">易用性：</h4>

<p>然后是结构图右边的 valuePool 部分。<code>valuePool</code> 是 <code>bufferValue</code> 对象的 sync.Pool。我们先来看 valuePool 的结构：</p>

<p><a href="https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L105">http://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L105</a></p>

<pre><code class="language-go">// bufferValue is buffer pool's Value
type bufferValue struct {
	value    [maxBufferPool]interface{}
	transmit [maxBufferPool]interface{}
}
</code></pre>

<p>其中 <code>value/transmit</code> 域用来保存从注册表初始化出来的内存对象（transmit 域保存着从其他 context 复制过来的内存对象），数组的索引与上文说的 index 值对应，而数组值即待复用对象的指针。全局变量 <code>vPool</code> 保存了 bufferValue 的 sync.Pool，即 bufferValue 本身也是可以复用的。</p>

<p>使用时，通过 <code>NewBufferPoolContext</code> 方法新建一个 bufferValue：</p>

<p><a href="https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L112">https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L112</a></p>

<pre><code class="language-go">// NewBufferPoolContext returns a context with bufferValue
func NewBufferPoolContext(ctx context.Context) context.Context {
	return mosnctx.WithValue(ctx, types.ContextKeyBufferPoolCtx, newBufferValue())
}


// newBufferValue returns bufferValue
func newBufferValue() (value *bufferValue) {
	// 从 vPool 里 get 复用的 bufferValue
	v := vPool.Get()
	if v == nil {
		value = new(bufferValue)
	} else {
		value = v.(*bufferValue)
	}
	return
}
</code></pre>

<p>获取内存对象时，调用 <code>PoolContext</code> 方法获取 bufferValue 对象，传入注册表对象调用其 <code>Find</code> 方法，Find 方法会根据注册表对象获取 index，并且初始化一个内存对象放在 value 域里。</p>

<p><a href="https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L182">https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L182</a></p>

<pre><code class="language-go">PoolContext(ctx context.Context) *bufferValue {
	if ctx != nil {
		if val := mosnctx.Get(ctx, types.ContextKeyBufferPoolCtx); val != nil {
			return val.(*bufferValue)
		}
	}
	return newBufferValue()
}
</code></pre>

<p><a href="https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L138">https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L138</a></p>

<pre><code class="language-go">(bv *bufferValue) Find(poolCtx types.BufferPoolCtx, x interface{}) interface{} {
	i := poolCtx.Index()
	if i &lt;= 0 || i &gt; int(index) {
		panic(&quot;buffer should call buffer.RegisterBuffer()&quot;)
	}
	if bv.value[i] != nil {
		return bv.value[i]
	}
	return bv.Take(poolCtx)
}

// Take returns buffer from buffer pools
func (bv *bufferValue) Take(poolCtx types.BufferPoolCtx) (value interface{}) {
	i := poolCtx.Index() // 获取 index 值
	value = bPool[i].take() // 调用注册表获取对象
	bv.value[i] = value // 放入 value
	return
}
</code></pre>

<p>使用完毕，只需调用 bufferValue 的 <code>Give</code> 方法，该方法会将其下管理的内存对象都归还到对应的 Pool 去，并且将自己归还到 vPool。</p>

<p><a href="https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L158">https://github.com/mosn/mosn/blob/master/pkg/buffer/buffer.go#L158</a></p>

<pre><code class="language-go">// Give returns buffer to buffer pools
func (bv *bufferValue) Give() {
	if index &lt;= 0 {
		return
	}
	// first index is 1
	// 归还 value &amp; transmit
	for i := 1; i &lt;= int(index); i++ {
		value := bv.value[i]
		if value != nil {
			bPool[i].give(value)
		}
		value = bv.transmit[i]
		if value != nil {
			bPool[i].give(value)
		}
	}
	bv.value = nullBufferValue
	bv.transmit = nullBufferValue

	// Give bufferValue to Pool
	// 归还自己
	vPool.Put(bv)
}
</code></pre>

<p>小结：MOSN 的 buffer 包保存了待复用的内存对象的注册表（bPool对象），用来对待复用对象的初始化和管理；另外，MOSN 定义了统一管理待缓存对象的结构：bufferValue，统一保存通过注册表初始化出来的对象。</p>

<h3 id="2-byte-io-buffer-复用-1">2. byte/io buffer 复用</h3>

<h4 id="byte-buffer">byte buffer</h4>

<p>先来看相关的结构体：</p>

<pre><code class="language-go">// byteBufferPool is []byte pools
type byteBufferPool struct {
	minShift int
	minSize  int
	maxSize  int

	pool []*bufferSlot
}

type bufferSlot struct {
	defaultSize int
	pool        sync.Pool
}
</code></pre>

<p>每个 slot 对应一种尺寸的 byteBuffer 的 pool，以及 <code>defaultSize</code> 域保存着尺寸。<code>byteBufferPool</code> 对象的 <code>pool</code> 域保存着多个 slot。</p>

<p>为了提高复用率，当申请一个非 64 字节对齐尺寸的 byte buffer 时（如 200），MOSN 实际上会从 slot 2，即 defaultSize = 256 的 slot 返回对象，并返回切片 len = 200 的 byte 切片。</p>

<p>初始化时，将 64、128、256&hellip; 以此类推的尺寸的 byte slot 初始化到 byteBufferPool 的 pool 域内：</p>

<p><a href="https://github.com/mosn/mosn/blob/master/vendor/mosn.io/pkg/buffer/bytebuffer_pool.go#L49">https://github.com/mosn/mosn/blob/master/vendor/mosn.io/pkg/buffer/bytebuffer_pool.go#L49</a></p>

<pre><code class="language-go">// newByteBufferPool returns byteBufferPool
func newByteBufferPool() *byteBufferPool {
	p := &amp;byteBufferPool{
		minShift: minShift,
		minSize:  1 &lt;&lt; minShift,
		maxSize:  1 &lt;&lt; maxShift,
	}
	for i := 0; i &lt;= maxShift-minShift; i++ {
		slab := &amp;bufferSlot{
			// 通过左移算出 defaultSize = 64/128/256...等等
			defaultSize: 1 &lt;&lt; (uint)(i+minShift),
		}
		// 依次append
		p.pool = append(p.pool, slab)
	}

	return p
}
</code></pre>

<p>使用时，根据尺寸算出对应的 slot，从对应的 slot 返回该尺寸的 byte 数组：</p>

<p><a href="https://github.com/mosn/mosn/blob/master/vendor/mosn.io/pkg/buffer/bytebuffer_pool.go#L65">https://github.com/mosn/mosn/blob/master/vendor/mosn.io/pkg/buffer/bytebuffer_pool.go#L65</a></p>

<pre><code class="language-go">func (p *byteBufferPool) slot(size int) int {
	// 比如要获取 200 size 的 buffer
	if size &gt; p.maxSize {
		return errSlot
	}
	slot := 0
	shift := 0
	if size &gt; p.minSize {
		// size - 199
		// 位: 1100 0111,经过 8 次右移会&lt;=0
		size--
		for size &gt; 0 {
			size = size &gt;&gt; 1
			shift++
		}
		// slot = 8 - 6 = 2, 该 slot 的 defaultSize = 256
		slot = shift - p.minShift
	}

	return slot
}
</code></pre>

<p><a href="https://github.com/mosn/mosn/blob/master/vendor/mosn.io/pkg/buffer/bytebuffer_pool.go#L87">https://github.com/mosn/mosn/blob/master/vendor/mosn.io/pkg/buffer/bytebuffer_pool.go#L87</a></p>

<pre><code class="language-go">// take returns *[]byte from byteBufferPool
func (p *byteBufferPool) take(size int) *[]byte {
	slot := p.slot(size)
	if slot == errSlot {
		b := newBytes(size)
		return &amp;b
	}
	// slot = 2, 
	v := p.pool[slot].pool.Get()
	if v == nil {
		// 如果 slot get 方法没有返回, new 一个
		b := newBytes(p.pool[slot].defaultSize)
		b = b[0:size]
		return &amp;b
	}
	b := v.(*[]byte)
	// 调整切片长度为请求的 size
	*b = (*b)[0:size]
	return b
}
</code></pre>

<p>使用完毕时，对应的就是将 byte 数组放回对应的 slot 里，这里比较好理解，各位可以自行看源码：</p>

<p><a href="https://github.com/mosn/mosn/blob/master/vendor/mosn.io/pkg/buffer/bytebuffer_pool.go#L106">https://github.com/mosn/mosn/blob/master/vendor/mosn.io/pkg/buffer/bytebuffer_pool.go#L106</a></p>

<h4 id="io-buffer">io buffer</h4>

<p>io buffer 及 io buffer pool 就比较好理解了，主要是定义了与 IO 相关的接口，然后实现方法是基于上文 byte buffer 的使用方法的封装，即 read 是从 byte buffer 里读取、write 是将数据 copy 进 byte buffer。
有了上文的基础，这里大家可以根据源码去看具体的实现，并不难。</p>

<p><a href="https://github.com/mosn/mosn/blob/master/vendor/mosn.io/pkg/buffer/types.go#L34">https://github.com/mosn/mosn/blob/master/vendor/mosn.io/pkg/buffer/types.go#L34</a></p>

<p>IO 相关的接口：</p>

<pre><code class="language-go">type IoBuffer interface {
	Read(p []byte) (n int, err error)

	ReadOnce(r io.Reader) (n int64, err error)

	Write(p []byte) (n int, err error)

	WriteString(s string) (n int, err error)

	WriteTo(w io.Writer) (n int64, err error)
	...

}
</code></pre>

<h2 id="总结">总结</h2>

<p>本文根据 MOSN 的源码分析了 MOSN 对内存复用的设计和用法，其基于 sync.Pool 之上封装了一层自己的注册管理逻辑，增强了管理能力、易用性和复用性。</p>

<hr />

<p>参考资料:</p>

<ul>
<li><a href="https://github.com/mosn/mosn">MOSN 源码</a></li>
</ul>

            </div>
            
            <div class="post-comments">
                
            </div>
            
            <div class="push"></div>
        </div>
        <footer class="footer text-center">
<p>Copyright &copy; 2020 Hello, I&#39;m trainyao. -
<span class="credit">
	Powered by
	<a target="_blank" href="https://gohugo.io">Hugo</a>
	and
	<a target="_blank" href="https://github.com/LordMathis/hugo-theme-nix/">Nix</a> theme.
</span>
</p>
</footer>

    </body>
