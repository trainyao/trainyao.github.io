<!DOCTYPE html>
<html>

    <head>
        <title> MOSN 源码分析 - 插件机制 &middot; trainyao.github.io </title>

        <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.59.1" />


<script   src="https://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">


<link rel="stylesheet" href="https://trainyao.github.io/css/nix.css">


<link href="https://fonts.googleapis.com/css?family=Inconsolata%7COpen+Sans%7CConcert+One" rel="stylesheet">




    </head>

    <body>
        <header>
<nav class="navbar navbar-default navbar-fixed-top navbar-inverse font-header">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" id="green-terminal" href=https://trainyao.github.io/>trainyao@home ~ $</a>
		</div>

		
		<div class="collapse navbar-collapse" id="navbar-collapse-1">
			<ul class="nav navbar-nav navbar-right">
				<li>
					<a href="https://trainyao.github.io/">/home/trainyao</a>
				</li>
				
				
				<li class="dropdown">
                    
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">日志 <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        
                    		<li>
                    		<a href="/post/kubernetes">~/kubernetes</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/istio">~/service mesh/istio</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/gloo">~/service mesh/envoy/gloo</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/mosn">~/service mesh/mosn</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/skynet">~/skynet</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/translate">~/翻译</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/bookread/kubernetes_the_definitive_guide">~/读书笔记/kubernetes 权威指南</a>
				    		</li>
                		
                    		<li>
                    		<a href="/post/bookread/computer_system">~/读书笔记/深入理解计算机系统</a>
				    		</li>
                		
            		</ul>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
            		<a href="/post/thoughts">~/脑洞</a>
            		
        		</li>
        		
				
				<li class="dropdown">
                    
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">其他 <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        
                    		<li>
                    		<a href="/post/other/repid_develop">~/快速开发</a>
				    		</li>
                		
            		</ul>
            		
        		</li>
        		

			</ul>
		</div>
	</div>
</nav>
</header>

        <div class="container wrapper">
            <h1><a href="https://trainyao.github.io/post/mosn/source_filter/">MOSN 源码分析 - 插件机制</a></h1>
            <span class="post-date">Feb 9, 2020 </span>
            <div class="post-content">
                

<p>本文记录了对 MOSN 的源码研究 - MOSN 的插件机制, 以及如何创建自己的插件来扩展 MOSN。</p>

<p>本文的内容基于 MOSN v0.9.0。</p>

<h2 id="机制">机制</h2>

<p>使用过滤器模式来实现扩展是常见的设计模式，MOSN 也是使用了这种方式来构建可扩展性。</p>

<p>MOSN 把过滤器相关的代码放在了 <code>pkg/filter</code> 目录下：</p>

<pre><code class="language-bash">➜  mosn git:(2c6f58c5) ✗ ll pkg/filter
total 24
drwxr-xr-x   8 mac  staff   256 Feb  5 08:52 .
drwxr-xr-x  30 mac  staff   960 Feb  5 08:52 ..
drwxr-xr-x   3 mac  staff    96 Aug 28 22:37 accept
-rw-r--r--   1 mac  staff  2556 Feb  5 08:52 factory.go
-rw-r--r--   1 mac  staff  2813 Feb  5 08:52 factory_test.go
drwxr-xr-x   6 mac  staff   192 Aug 28 22:37 network
drwxr-xr-x   7 mac  staff   224 Aug 28 22:37 stream
-rw-r--r--   1 mac  staff  1248 Feb  5 08:52 types.go
➜  mosn git:(2c6f58c5) ✗
</code></pre>

<p>包括 <code>accept</code> 过程的 filter，<code>network</code> 处理过程的 filter，以及 <code>stream</code> 处理的 filter。其中 accept filters 目前暂不提供扩展（加载、运行写死在代码里面，如要扩展需要修改源码），
steram、network filters 是可以通过定义新包在 <code>pkg/filter</code> 目录下实现扩展。</p>

<p>每一个 filter 包都会有一个 init 函数，拿 <code>pkg/filter/network/proxy</code> 包为例：</p>

<pre><code class="language-bash">...

 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package proxy

import (
    ...
)

func init() {
	filter.RegisterNetwork(v2.DEFAULT_NETWORK_FILTER, CreateProxyFactory)
}

...
</code></pre>

<p>包被运行时会将 filter 注册到 filter factory 里，在必要时候，注册的回调函数（如例子里的 <code>CreateProxyFactory</code>）就会被调用。</p>

<h2 id="加载-运行-filters">加载 &amp; 运行 filters</h2>

<p>下面来详细看看 filters 被加载和运行的过程。</p>

<h3 id="加载">加载</h3>

<p>我们可以看看，init 函数注册的回调函数是在什么时机被调用的：</p>

<p><a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/filter/factory.go#L57">mosn.io/mosn/pkg/filter/factory.go L57:</a></p>

<pre><code class="language-go">...
// CreateNetworkFilterChainFactory creates a StreamFilterChainFactory according to filterType
func CreateNetworkFilterChainFactory(filterType string, config map[string]interface{}) (types.NetworkFilterChainFactory, error) {
	if cf, ok := creatorNetworkFactory[filterType]; ok {
...
</code></pre>

<p>↓</p>

<p><a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/config/parser.go#L372">mosn.io/mosn/pkg/config/parser.go L372:</a></p>

<pre><code class="language-go">...
// GetNetworkFilters returns a network filter factory by filter.Type
func GetNetworkFilters(c *v2.FilterChain) []types.NetworkFilterChainFactory {
	var factories []types.NetworkFilterChainFactory
	for _, f := range c.Filters {
		factory, err := filter.CreateNetworkFilterChainFactory(f.Type, f.Config)
...
</code></pre>

<p>可见，MOSN 在调用 <code>config.GetNetworkFilters</code> 会根据<code>配置信息</code>中 <code>filter.Type</code> 作为名字，在已注册的 filters 中找到需要加载的 filter，并返回 networkFilterChainFactory。
可以看到， <code>filter.Type</code> 其实就是 init 函数调用时，包调用 <code>filter.RegisterNetwork</code> 函数的第一个参数：filter 名。</p>

<p>那么，配置信息又是从哪里来的呢？</p>

<ol>
<li><p>配置。用户可以通过定义 MOSN 的 config.json，MOSN 启动时会根据 listener 指定的 filter 数组进行 filters 的初始化。</p>

<ul>
<li><p><a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/mosn/starter.go#L173">https://github.com/mosn/mosn/blob/0.9.0/pkg/mosn/starter.go#L173</a></p>

<pre><code class="language-go">func NewMosn(c *config.MOSNConfig) *Mosn {
...
        
    var nfcf []types.NetworkFilterChainFactory
    var sfcf []types.StreamFilterChainFactory
        
    // Note: as we use fasthttp and net/http2.0, the IO we created in mosn should be disabled
    // network filters
    if !lc.UseOriginalDst {
        // network and stream filters
        nfcf = config.GetNetworkFilters(&amp;lc.FilterChains[0])
        sfcf = config.GetStreamFilters(lc.StreamFilters)

...
</code></pre></li>
</ul></li>

<li><p>XDS 信息解析。MOSN 里的 XDS client 会将 XDS resources 解析成 MOSN 的 config，当 downstream client 连接进来的时候根据 config 进行组装需要用到的 filters。</p>

<ul>
<li><p><a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/xds/conv/update.go#L71">https://github.com/mosn/mosn/blob/0.9.0/pkg/xds/conv/update.go#L71</a></p>

<pre><code class="language-go">// ConvertAddOrUpdateListeners converts listener configuration, used to  add or update listeners
func ConvertAddOrUpdateListeners(listeners []*envoy_api_v2.Listener) {
...
    var streamFilters []types.StreamFilterChainFactory
    var networkFilters []types.NetworkFilterChainFactory
      
    if !mosnListener.UseOriginalDst {
        for _, filterChain := range mosnListener.FilterChains {
            nf := config.GetNetworkFilters(&amp;filterChain)
            networkFilters = append(networkFilters, nf...)
        }
        streamFilters = config.GetStreamFilters(mosnListener.StreamFilters)
...
</code></pre></li>
</ul></li>
</ol>

<p>所以，filters 的配置主要是来源于配置文件。</p>

<h3 id="运行">运行</h3>

<p>filters 的配置是在 listener 之下的，配置解析会将每个 listener 配置声明要用到的 filters 初始化到 listener 实例里，在连接 accept 以及处理过程中，调用上文的函数初始化 filters 并调用。</p>

<p>MOSN 会将连接的上下文信息放在 context 内传给 filter，并将 stream 传给 filter。下面是代码流程：</p>

<ol>
<li><p>连接 accept</p>

<p><a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/server/handler.go#L394">https://github.com/mosn/mosn/blob/0.9.0/pkg/server/handler.go#L394</a></p>

<pre><code class="language-go">func (al *activeListener) OnAccept(rawc net.Conn, useOriginalDst bool, oriRemoteAddr net.Addr, ch chan types.Connection, buf []byte) {
...
arc.ContinueFilterChain(ctx, true)
</code></pre></li>

<li><p>将连接上下文放入 context，并用以创建 filter chain，并初始化 filter manager，执行 filters 的 <code>OnNewConnection</code> 函数。
filter manager 是 filters 的代理，外部会在不同阶段调用 filter manager 的不同函数，filter manager 管理 filters 的执行逻辑</p>

<ol>
<li><p><a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/server/handler.go#L394">https://github.com/mosn/mosn/blob/0.9.0/pkg/server/handler.go#L394</a></p>

<pre><code class="language-go">func (al *activeListener) OnAccept(rawc net.Conn, useOriginalDst bool, oriRemoteAddr net.Addr, ch chan types.Connection, buf []byte) {
...
   
ctx := mosnctx.WithValue(context.Background(), types.ContextKeyListenerPort, al.listenPort)
ctx = mosnctx.WithValue(ctx, types.ContextKeyListenerType, al.listener.Config().Type)
ctx = mosnctx.WithValue(ctx, types.ContextKeyListenerName, al.listener.Name())
ctx = mosnctx.WithValue(ctx, types.ContextKeyNetworkFilterChainFactories, al.networkFiltersFactories)
ctx = mosnctx.WithValue(ctx, types.ContextKeyStreamFilterChainFactories, &amp;al.streamFiltersFactoriesStore)
ctx = mosnctx.WithValue(ctx, types.ContextKeyAccessLogs, al.accessLogs)
if rawf != nil {
   ctx = mosnctx.WithValue(ctx, types.ContextKeyConnectionFd, rawf)
}
if ch != nil {
   ctx = mosnctx.WithValue(ctx, types.ContextKeyAcceptChan, ch)
   ctx = mosnctx.WithValue(ctx, types.ContextKeyAcceptBuffer, buf)
}
if oriRemoteAddr != nil {
   ctx = mosnctx.WithValue(ctx, types.ContextOriRemoteAddr, oriRemoteAddr)
}
...
       
</code></pre></li>

<li><p><a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/server/handler.go#L454">https://github.com/mosn/mosn/blob/0.9.0/pkg/server/handler.go#L454</a></p>

<pre><code class="language-go">func (al *activeListener) OnNewConnection(ctx context.Context, conn types.Connection) {
//Register Proxy's Filter
filterManager := conn.FilterManager()
for _, nfcf := range al.networkFiltersFactories {
    nfcf.CreateFilterChain(ctx, al.handler.clusterManager, filterManager)
}
filterManager.InitializeReadFilters()
...
</code></pre></li>
</ol></li>

<li><p>执行 filter 的 <code>OnData</code> 方法</p>

<p><a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/network/connection.go#L428">https://github.com/mosn/mosn/blob/0.9.0/pkg/network/connection.go#L428</a> -&gt;
<a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/network/connection.go#L484">https://github.com/mosn/mosn/blob/0.9.0/pkg/network/connection.go#L484</a></p>

<pre><code class="language-go">func (c *connection) doRead() (err error) {
...
    c.onRead()
...
    
func (c *connection) onRead() {
...
c.filterManager.OnRead()
</code></pre></li>
</ol>

<p>至此，filter 就实现了对连接的干预，filter 就像中间件，可以返回 <a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/types/network.go#L148">type.Continue</a> 控制连接继续进行，
也可以返回 <a href="https://github.com/mosn/mosn/blob/0.9.0/pkg/types/network.go#L149">type.Stop</a> 停止连接继续处理。即可以对连接内容进行干预，比如在 static response 的场景，
返回既定的 response 内容；也可以对连接处理流程进行干预，比如在 fault injection 的场景，增加连接延时，等等。</p>

<h2 id="mosn-实现了的-filters">MOSN 实现了的 filters</h2>

<p>根据文件目录我们可以看出 MOSN 目前实现了哪些 filter：</p>

<pre><code class="language-text">
➜  mosn git:(2c6f58c5) ✗ ll pkg/filter/network
total 0
drwxr-xr-x   7 mac  staff  224 Aug 28 22:37 .
drwxr-xr-x   8 mac  staff  256 Feb  9 15:49 ..
drwxr-xr-x  3 mac  staff   96 Feb  8 10:35 connectionmanager // 连接管理
drwxr-xr-x  4 mac  staff  128 Feb  5 08:52 faultinject // 错误注入相关
drwxr-xr-x  3 mac  staff   96 Feb  9 12:37 proxy // 代理逻辑, 这个 filter 目前是 MONS 里的逻辑一部分, 负责将 stream 发送到 serverStream, 开启流量的代理
drwxr-xr-x  6 mac  staff  192 Feb  5 08:52 tcpproxy // tcp 代理逻辑

➜  mosn git:(2c6f58c5) ✗ ll pkg/filter/stream
total 0
drwxr-xr-x   7 mac  staff  224 Aug 28 22:37 .
drwxr-xr-x   8 mac  staff  256 Feb  9 15:49 ..
drwxr-xr-x  11 mac  staff  352 Feb  5 08:52 commonrule // stream filter 逻辑公共部分, rule engine 等等
drwxr-xr-x   6 mac  staff  192 Feb  5 08:52 faultinject // 错误注入相关
drwxr-xr-x   3 mac  staff   96 Aug 28 22:37 healthcheck // upstream 健康检查相关
drwxr-xr-x   3 mac  staff   96 Feb  5 08:52 mixer // mixer 逻辑相关
drwxr-xr-x   4 mac  staff  128 Feb  5 08:52 payloadlimit // 限流相关
</code></pre>

<p>具体每个 filter 的逻辑都可以根据下述的 filter 结构，进行代码跟读和调试，分别理解每个 filter 的作用。</p>

<h2 id="filter-包含的内容-如何扩展-mosn-filters">filter 包含的内容 &amp; 如何扩展 MOSN filters</h2>

<p>一个 filter 包含以下内容：</p>

<ol>
<li>init 函数，register 创建 filter manager 的回调函数</li>
<li>回调函数需要返回一个实现了 <code>types.NetworkFilterChainFactory</code> 接口的 struct</li>
<li>该 struct 的 <code>CreateFilterChain</code> 方法创建具体逻辑的实例，并调用 <code>callback</code> 参数的 <code>addReadFilter</code> | <code>addWriteFilter</code> 函数，进行 filter 注入到 filter manager</li>
<li>具体的业务逻辑</li>
</ol>

<p>由此可见，通过 filter 机制扩展 MOSN，我们只需实现上述 4 样东西，与 MOSN 一同编译。再通过适当的 config 内容配置，或者与 XDS server 协作并生成含有你扩展的 filter 名及配置
（这部分需要修改 MOSN 源码，MOSN 与 XDS server 交互并生成 config，选用哪些 filter 目前是写死在代码里的），MOSN 就会在适当时候加载并运行你的 filter，对代理流量进行干预。</p>

<h2 id="总结">总结</h2>

<p>本文通过分析 MOSN 源码，简述了 MOSN 的插件扩展机制，并简述了实现自己的 filter 需要做的东西。大家可以通过该机制，使用 MONS 轻松 cover 自己具体的使用场景。</p>

<hr />

<p>参考资料:</p>

<ul>
<li><a href="https://github.com/mosn/mosn">MOSN 源码</a></li>
</ul>

            </div>
            
            <div class="post-comments">
                
            </div>
            
            <div class="push"></div>
        </div>
        <footer class="footer text-center">
<p>Copyright &copy; 2020 Hello, I&#39;m trainyao. -
<span class="credit">
	Powered by
	<a target="_blank" href="https://gohugo.io">Hugo</a>
	and
	<a target="_blank" href="https://github.com/LordMathis/hugo-theme-nix/">Nix</a> theme.
</span>
</p>
</footer>

    </body>
