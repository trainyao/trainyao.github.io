<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on trainyao.github.io</title>
    <link>https://trainyao.github.io/post/</link>
    <description>Recent content in Posts on trainyao.github.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://trainyao.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://trainyao.github.io/post/bookread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://trainyao.github.io/post/bookread/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://trainyao.github.io/post/java/spring/spring_springboot_ioc_di/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://trainyao.github.io/post/java/spring/spring_springboot_ioc_di/</guid>
      <description>@(linux)
#Spring与SpringBoot的IoC和DI ###前言 spring的内容有很多，而springBoot对于spring的优化的内容也有非常多方面可讲。这次主要分享的是spring和springBoot中的IoC和DI，以及我所看到的在我们java项目中的体现。
##Ioc(控制反转) 控制反转即反转控制类实例的方式。 从控制反转为被控制 从自己生成/销毁反转为别人生成/销毁 控制反转的好处在于： - 业务逻辑中不用考虑实例的生成/销毁，可以专注于业务逻辑(使用类实例) - 对测试更加友好(mock实例行为)
##DI(依赖注入) 依赖注入是控制反转的一种实现方法。&amp;rdquo;别人&amp;rdquo;管理类实例的生成/销毁，并将业务逻辑需要用到的类实例注入进来。
##Spring的IoC 一个Spring应用有一个应用上下文（ApplicationContext），充当类实例的容器，管理着类实例的生成和销毁，并在应用需要时返回/注入对应的类实例。 Spring按类实例的种类管理容器中的类实例（种类有唯一的种类id：beanId）。每一种类实例称为Bean。 与很多IoC框架类似，类实例的注入方式有很多种(单例/非单例)，Spring中类实例存在方式可以是： - 单例 (singleton) - 每次注入返回新的实例 (prototype) - 每次请求返回同一的实例 (request) - 每次回话返回同一实例 (session/global session)
以下是spring注册Bean的其中某些特性： - 1. xml可以配置BeanId，默认以类名为beanId。 - 2. 注解为bean的时候默认以类名为beanId，也可以指定beanId - 3. 在获取bean时，如果无法查找到beanId，会查找对应的类是否有注册，如果不存在，会查找对应类的子类是否有注册
另外，spring的IoC和DI利用了java的注解实现，也是面向切面编程的一个体现。在加载应用的时候，切换到应用bean管理切面，扫描类并注册Bean，在需要注入时，再次切换到bean管理切面，返回需要的bean。
##SpringBoot的IoC springBoot简化了spring的配置部分 spring通过xml配置文件扫描/注解方式注册类实例 springBoot默认通过注解方式注册类实例，并默认扫描application包以及子包的所有类实例。默认以注解方式标记类实例。 springBoot可以沿用spring注解配置Bean时的规则</description>
    </item>
    
    <item>
      <title></title>
      <link>https://trainyao.github.io/post/other/repid_develop/linux_alias/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://trainyao.github.io/post/other/repid_develop/linux_alias/</guid>
      <description># git alias gs=&#39;git status &#39; alias ga=&#39;git add &#39; # usage: gc &#39;comment info&#39; alias gc=&#39;git commit -m &#39; alias gd=&#39;git diff &#39; alias gsh=&#39;git show &#39; alias grm=&#39;git rm &#39; alias gck=&#39;git checkout &#39; alias gps=&#39;git push origin &#39; alias gpl=&#39;git pull origin &#39; alias gpl=&#39;git branch | grep \* | cut -d &amp;quot; &amp;quot; -f 2 | xargs git pull origin &#39; alias grs=&#39;git reset &#39; alias gl=&#39;git log &#39; alias gb=&#39;git branch &#39; alias gmg=&#39;git merge &#39; alias gst=&#39;git stash &#39; alias gf=&#39;git fetch&#39; alias grollback=&amp;quot;gl | grep commit | head -n 1 | awk &#39;{print \$2}&#39; | xargs -I {} git reset --hard {}&amp;quot; alias u=&#39;gck online gb -D develop gb -D master git fetch gck develop gck master &#39; # other alias ll=&#39;ls -al&#39; alias ip=&#39;ifconfig | grep 172&#39; # docker alias de=&#39;docker exec -it &#39; alias dp=&#39;docker ps&#39; alias dpa=&#39;docker ps -a&#39; alias di=&#39;docker images&#39; alias drmi=&#39;docker rmi &#39; alias drm=&#39;docker rm &#39; alias dr=&#39;docker run &#39; alias dk=&#39;docker kill &#39;  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://trainyao.github.io/post/php/php_extension/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://trainyao.github.io/post/php/php_extension/overview/</guid>
      <description>@(PHP) ###PHP扩展分享 ###什么时候需要写php扩展 * 有需要使用php调用C/C++函数库 * 实现php没有的功能 * 优化php性能
###php扩展简介 php提供一个工具用来生成php扩展的代码,类似代码生成器,工具目录source/to/php_source_code/ext/ext_skel,这个是供类unix平台调用的脚本,php源码也提供了一个供windows平台调用的脚本,用来生成php扩展代码.该脚本是个php脚本,在source/to/php_source_code/ext/ext_skel_win32.php
php将扩展代码统一放到source/to/php_source_code/ext/下,这样当开发者按照工具生成对应格式的php扩展源码,并统一放到这个目录下,php源码就会自动识别,并可以选在在编译时加上开发者的扩展. ###先找个题目 总所周知php在连接字符串会进行多次初始化临时变量,和内存复制.假设有一个变态的需求需要重复一个字符串&amp;rsquo;a&amp;rsquo; n次,并且在系统中多次出现,由于n已知,为了提高性能,可以考虑用扩展实现 ###动手 ####1. 编写扩展原型文件,使用工具生成扩展代码
php没有规定原型文件的文件后缀,但有规定原型文件的格式. 如果你的扩展需要暴露出接口函数供php代码调用,原型文件只需包含接口函数的原型.接口函数原型包括函数输入参数的类型和名字,还有函数返回的类型.其中类型支持php的变量类型.如bool,int,string,float等等.. 根据上面的需求,创建一个名为repeatString的函数,返回类型为string,接受一个string类型的$inputString字符串,和一个int类型的$repeatCount,表示输出$inputString被重复$repeatCount次的字符串. 首先进入ext目录
cd path/to/php_source_code/ext &amp;amp;&amp;amp; \ vim repeatString.proto  编写内容
string repeatString(string inputString, int repeatCount)  保存,使用ext_skel工具生成扩展框架,可以指定扩展名和扩展的原型文件
./ext_skel --extname=repeatString --proto=repeatString.proto  你会看到ext目录下会多了一个repeatString的文件夹,里面放的就是你扩展的所有所需文件 需要留意的有几个文件:
 config.m4 &amp;ndash; *unix平台下配置文件,这里是官方解释:   扩展的 config.m4 文件告诉 UNIX 构建系统哪些扩展 configure 选项是支持的，你需要哪些扩展库，以及哪些源文件要编译成它的一部分。对所有经常使用的 autoconf 宏，包括 PHP 特定的及 autoconf 内建的，请查看 Zend Engine 2 API 参考 章节。
  config.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://trainyao.github.io/post/skynet/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://trainyao.github.io/post/skynet/overview/</guid>
      <description>这个星期以来，由于工作需要使用skynet，于是看了5天skynet的源码。收获很多，于是周末写篇博文总结一下这周以来的学习。 这5天的学习过程可以概括为5句话：（因为5天嘛） 1. 代码结构，从main函数开始 2. skynet启动过程，worker线程工作过程 3. skynet启动过程，skynet数据结构熟悉， 4. worker回调函数注册，worker的c层回调lua逻辑原理， 5. lua层逻辑协程的使用熟悉，服务之间通过消息交互的过程
看了5天后回过头来发现，其实了解的还停留在skynet的核心部分，还没有走出核心。因为skynet还包含很多其他内容，比如他的消息机制的各种api、socket支持、loginserver gateserver、datacenter、harbor等等。。。 不过问题也不大，毕竟核心比较重要，后续还要继续学习。 那下面就来总结一下这5天都看到来什么内容。有可能因为我了解尚浅，写出来的和实际的skynet有出入。不过没关系，后续会回过头来再看看。
下面的总结会按照这个结构： - 源码目录结构 - skynet的结构图以及工作过程
那么，开始吧。
1. 源码目录结构 可以用一个段落来说明
``` shell $ ll drwxr-xr-x 26 root staff 884 6 1 06:30 . drwxr-xr-x 5 root staff 170 6 2 07:07 .. drwxr-xr-x 12 root staff 408 6 1 07:10 .git -rw-r&amp;ndash;r&amp;ndash; 1 root staff 94 6 1 05:36 .gitignore -rw-r&amp;ndash;r&amp;ndash; 1 root staff 96 6 1 05:36 .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://trainyao.github.io/post/skynet/timer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://trainyao.github.io/post/skynet/timer/</guid>
      <description>skynet里的定时器 这周花了点时间看了skynet关于定时器功能的源码,以及扩展的了解了一下定时器实现的其他方案,写一遍博客总结一下.内容会分为下面几部分:
 skynet的定时器结构图 skynet定时器执行过程 关于skynet定时器的一些思考 其他定时器方案 linux定时器方案 总结  1. skynet的定时器结构图 2. skynet定时器执行过程 首先确定定时器里面的几个概念:
 tick: 指skynet timer线程每一次处理事件的循环.由于这个循环每隔0.00025秒会执行一次,很像时钟滴答滴答的走,很多书籍都称为tick skynet启动时间戳: 顾名思义,比如1528613417时间戳(北京时间2018/6/10 14:50:17)代表skynet是这个时间点启动的,而且这个时间是不会变的.这个比较容易理解 系统启动时间数: 单位0.01秒. 顾名思义,但是为什么说是时间数呢?因为这是一个时间的量,比如300,表示系统启动了3秒.skynet timer线程在每一次tick都会去同步这个时间量 skynet启动时间数: 单位0.01秒. 与系统启动时间数类似,如300,表示skynet启动了3秒,每次tick skynet timer线程也会去更新这个时间量  首先需要说明的是,skynet定时器的时间刻度是百分秒(0.01秒).意味着skynet最小可以定义事件0.01秒后执行.这个精度对于游戏领域可以说是够用了.
skynet初始化时会创建5个定时器的事件槽,分别是Near,level0-3.每个定时器事件是按照触发时间(这个触发时间是以skynet启动时间数作为参照的.比如触发时间为300,事件注册时skynet创建时间量为100,表示注册这个事件在2秒后执行)为索引插入到对应的槽里面的.用索引的方式安排这些事件保证了查询和插入的性能( 时间复杂度为O(1) ).
那skynet是怎么安排这些事件应该放入哪个槽呢? 5个不同的槽又是什么关系呢?
skynet根据触发时间得出事件应该插入到哪个槽,哪个索引.触发时间是一个32位的整型值.skynet将这32位分为 6 6 6 6 8位每个区间.如果前24位有值,表示这个事件是比较延后触发的,skynet将它们安排到level槽里面,表示这些事件暂时不关注,高0-6位有值的插入到level 3槽里,高7-12位有值的插入到level 2槽里,如此类推,高19-24位有值的,插入到level 0槽里.而高24位没有值,低8位有值的事件,skynet认为是需要比较关注的事件,并以低8位为索引插入到Near(near可能就是比较近会发生的事件的意思)槽里.具体插入后的结果就像上面图中画的一样.
skynet timer的每次tick,都会以系统时间为参照,检查这次tick落后了系统时间多少百分秒,然后将落后的系统时间同步回skynet启动时间数里,并执行这个时间数低8位为索引的Near槽里的事件.
你可能会有一个疑惑,假如我注册了一个0x01 01为触发时间的事件A(这个事件应该被插入到Level 0[0x01]槽里),还有一个0xff为触发时间的事件B(这个事件应该被插入到Near[0xff]槽里),当时间走到0xff时,时间B会被顺利执行.但是当时间走到0x01 01时,时间A怎么办?它会被怎么执行?
skynet在每个高24有值的&amp;quot;整点&amp;quot;,都会将对应的Level槽里的事件整理到Near槽里,然后执行.高24位有值的整点指0x0f00 0x0100 0x1000 0000这些时间点.如上面的例子,当时间走到0x0100的时候,skynet会将Level 0[0x01(0x0101 的低15-9位是0x01)]槽里的事件整理到Near槽里,即将事件B插入到Near[0x01(0x0101 的低8-0位是0x01)]槽里.时间再走1个百分秒,timer线程就会执行Near[0x01]槽里的事件,就会将事件B处理掉了.
这也是为什么上图在Near[0xf0]里会有事件的触发时间是0xf0,也有的是0x0f f0,0x0f f0的事件是timer线程从Level 0槽里整理过去的.只不过,上图有一点不对的是,0xf0和0x0f f0时间不可能同时存在在Near[0xf0]里面,这里只是为了说明Near槽里面有可能出现的事件,忽略细节.而Level 0槽里,一个索引的列表会有低8位有各种值的事件包含在里面,等到timer线程走到整点的时候,再被处理整理到Near槽里面去.
上面就是skynet定时器整个工作的过程.用索引的方式保证了插入和查询的高效,而分槽的方式保证了触发事件的高效,着急的事件重点关注,不着急的事件延后处理.而按66668位每个区间来划分和注册事件,使用位操作作为哈希算法提升了插入和查找的性能.
3. 关于skynet定时器的一些思考  timer线程在处理Near槽一个索引的事件队列时,如果同时有事件插入到这个槽里,会发生什么呢?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://trainyao.github.io/post/thoughts/lockmash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://trainyao.github.io/post/thoughts/lockmash/</guid>
      <description> Lock mesh  想法  前些天在研究分布式锁的方案，突发奇想，在云原生时代，像 php、c、go、java 这种原来用特定编程语言开发的程序，已经通过打包、编排，变成了云原生操作系统里的一个工作进程。而像是网络这种原本的操作系统基础设施，也在云原生操作系统里面有了实现（从微服务发展到 service mesh）。
那么，锁是不是也可以看作是基础设施，提供给云原生操作系统的工作进程使用呢？
云原生开发者在编写工作进程逻辑的时候，无需考虑引入哪个分布式锁的包/库，就像是调用系统调用一样，将资源锁住，读写资源，然后再调用系统调用进行解锁。而云原生操作系统负责调度容器进行资源的访问，防止容器争抢资源。这样做的好处是，可以屏蔽掉不同语言的分布式锁之间的实现差异，让业务逻辑开发者专注业务逻辑的优化、思考业务应该使用哪种锁，以及锁的粒度等业务相关的工作。
其实不止是锁，也许还可以思考一下，原生操作系统的基础设施有哪些可以对应到云原生操作系统上的。
且不论叫它 lock mesh 是否合理吧：）
有这个想法后，我在 github、google 和 CNCF landscape 上搜索了一番，没有找到相关的项目或者资料。后续我会再进行一些搜索，确定我是不是想别人已经想到的东西。
如果你也觉得这个想法可行，不妨跟我联系哦：）
 怎么办  有了想法，然后呢？
我列了一些 todo 项：
 再搜索一下是否已经存在相关的资料、项目 思考这个方案是否有必要，是否可行  有没有必要做这一层抽象，编写容器逻辑的开发者，其实是不是按照原来的方式，调用库就好了 如果要做，怎么基于云原生平台（像是 kubernetes）去实现这种基础设施  如果可行，根据具体方案，给出架构图 立项，做项目规划 写demo 开源出去，让更多的开发者接触到项目，并参与代码贡献 建立社区，完善文档（微信群、钉钉群（国内）、slack（国外））  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://trainyao.github.io/post/welcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://trainyao.github.io/post/welcome/</guid>
      <description>author: jockchou head: http://pingodata.qiniudn.com/jockchou-avatar.jpg date: 2015-07-31 title: 欢迎使用GitBlog tags: GitBlog images: http://pingodata.qiniudn.com/cube2.jpg category: GitBlog status: publish summary: GitBlog是一个简单易用的Markdown博客系统，它不需要数据库，没有管理后台功能，更新博客只需要添加你写好的Markdown文件即可。 &amp;ndash;&amp;gt;
一. 简介 GitBlog是一个简单易用的Markdown博客系统，它不需要数据库，没有管理后台功能，更新博客只需要添加你写好的Markdown文件即可。它摆脱了在线编辑器排版困难，无法实时预览的缺点，一切都交给Markdown来完成，一篇博客就是一个Markdown文件。同时也支持评论，代码高亮，数学公式，页面PV统计等常用功能。GitBlog提供了不同的主题样式，你可以根据自己的喜好配置，如果你想自己制作博客主题，也是非常容易的。GitBlog还支持整站静态导出，你完全可以导出整站静态网页部署到Github Pages。
二. 功能特点  使用Markdown
 评论框
 代码高亮
 PV统计
 Latex数学公式
 自制主题
 响应式
 全站静态导出
 良好的SEO
  三. GitBlog优势  无需数据库，系统更轻量，移植更方便
 使用Markdown编写，摆脱后台编辑排版困难，无法实时预览的缺点
 可全站静态导出
 配置灵活，可自由开关某些功能
 多主题支持，可自制主题
 博客，分类，标签，归档
  四. 环境要求 PHP 5.2.4+
五. 安装步骤  下载GitBlog源代码</description>
    </item>
    
  </channel>
</rss>